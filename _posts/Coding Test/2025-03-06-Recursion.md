# 재귀함수 (Recursion Function)

## 📌 재귀함수란?

재귀함수는 **함수 안에서 자기 자신을 다시 호출하는 함수**를 말합니다.  
문제를 작은 단위로 쪼개서 반복적으로 해결할 수 있을 때 자주 사용되며, **반복문보다 직관적인 코드 작성이 가능**한 장점이 있습니다.

---

### ✅ 특징
- **자기 자신을 호출**함
- **기저 조건(Base Case)**이 반드시 존재해야 함
- 반복문으로도 구현 가능한 문제를 더 간결하게 표현할 수 있음
- **잘못 사용 시 스택 오버플로우**가 발생할 수 있음

---

### ✅ 사용 예시
- 피보나치 수열
- 팩토리얼 계산
- 하노이의 탑
- 백트래킹 알고리즘
- 트리 탐색 (DFS)

---

## 🧠 재귀함수의 구조

```
function 재귀함수(매개변수) {
    if (기저 조건) {
        return 종료값;
    }
    return 재귀함수(작은 문제로 나눈 값);
}
```

> **기저 조건(Base Case)**: 재귀 호출을 멈추는 조건  
> **재귀 단계(Recursive Case)**: 문제를 더 작게 나누어 자기 자신을 호출

---

## 💡 예시: 피보나치 수열 (Fibonacci Sequence)

### 📖 정의 (점화식)

```
F(n) = F(n - 1) + F(n - 2)
```

초기 조건:  
```
F(0) = 0,  F(1) = 1
```

```cpp
#include <iostream>
using namespace std;

int fibo(int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;
    return fibo(n - 1) + fibo(n - 2);
}

int main()
{
    cout << fibo(4) << endl; // 출력: 3
}
```

---

## ⚠️ 재귀 사용 시 주의할 점

- 재귀 호출이 많아질 경우 **속도가 매우 느려질 수 있음**
- 같은 계산을 반복하면 **중복 계산이 발생** → 성능 저하
- **메모이제이션(Memoization)** 또는 **반복문**으로 개선 가능

---

## 🚀 피보나치 수열 - 메모이제이션 적용 (DP 방식)

```cpp
#include <iostream>
using namespace std;

int memo[100];

int fibo(int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;

    if (memo[n] != -1) return memo[n]; // 이미 계산된 값이면 재사용
    return memo[n] = fibo(n - 1) + fibo(n - 2);
}

int main()
{
    fill(memo, memo + 100, -1); // 초기화
    cout << fibo(40) << endl;   // 빠르게 계산
}
```

---

## ✅ 정리

| 항목   | 설명                                        |
| ------ | ------------------------------------------- |
| 장점   | 코드 간결, 구조 명확, 트리/탐색 문제에 유리 |
| 단점   | 속도 느림, 스택 오버플로우 위험             |
| 해결책 | 기저 조건 설정, 메모이제이션 사용           |
